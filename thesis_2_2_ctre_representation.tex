\section{CTRE Automata Representation}

CTRE employs compile-time pattern compilation, transforming regular expression strings into C++ template type hierarchies that encode pattern structure and matching semantics. This section describes the type-based representation and evaluation model that forms the substrate for SIMD optimization.

\subsection{Compile-Time Pattern Parsing}

Regular expression patterns are processed at compilation via a constexpr parser that produces a type-level abstract syntax tree (AST). The transformation occurs in two phases:

\begin{enumerate}
    \item \textbf{Lexical analysis and parsing}: A compile-time LL parser (\texttt{ctll::parser}) processes the pattern string using PCRE syntax rules, producing a parse tree represented as nested template types.

    \item \textbf{Type extraction}: The parser output is a compile-time type stack from which the final pattern type is extracted via \texttt{ctll::front()}.
\end{enumerate}

\noindent Example transformation for pattern \texttt{[a-z]+}:
\begin{verbatim}
using Pattern = repeat<1,        // minimum: 1
                       0,        // maximum: unlimited (0)
                       set<char_range<'a', 'z'>>>;
\end{verbatim}

\subsection{Type-Based AST Structure}

The pattern AST comprises a small set of fundamental type templates defined in \texttt{atoms.hpp}:

\begin{itemize}
    \item \texttt{character<C>}: Single character literal
    \item \texttt{string<C1, C2, ...>}: String literal (compile-time character sequence)
    \item \texttt{set<...>}: Character class (may contain \texttt{char\_range}, negation, named sets)
    \item \texttt{repeat<A, B, Content...>}: Repetition with bounds [\textit{A}, \textit{B}]
    \item \texttt{sequence<...>}: Sequential composition of subpatterns
    \item \texttt{select<Opt1, Opt2, ...>}: Alternation (disjunction)
    \item \texttt{capture<N, ...>}: Capturing group
    \item \texttt{lookahead\_positive<...>}, \texttt{lookbehind\_positive<...>}: Assertions
    \item \texttt{back\_reference<N>}: Backreference to captured group
\end{itemize}

Pattern composition occurs via template parameter nesting. The pattern \texttt{(ab)+[0-9]} produces:
\begin{verbatim}
sequence<repeat<1, 0, sequence<character<'a'>,
                               character<'b'>>>,
         set<char_range<'0', '9'>>>
\end{verbatim}

\subsection{Template-Driven Evaluation}

Pattern matching proceeds through recursive template function instantiation. The core evaluation function has signature:
\begin{verbatim}
template <typename R, typename BeginIt, typename It,
          typename EndIt, typename... Pattern>
constexpr R evaluate(BeginIt begin, It current,
                    EndIt last, flags f, R captures,
                    ctll::list<Pattern...>);
\end{verbatim}

Evaluation consumes pattern types from the type list, advancing the input iterator as characters are matched. Template specialization provides distinct logic for each pattern type. For \texttt{repeat<A, B, Content...>}, the specialization:

\begin{enumerate}
    \item Attempts to match \texttt{Content} between $A$ and $B$ times
    \item Advances the iterator for each successful match
    \item Recurses with remaining pattern types on success
    \item Backtracks on failure (for greedy quantifiers)
\end{enumerate}

The type list (\texttt{ctll::list}) serves as a compile-time instruction sequence, with each type representing an operation in the matching algorithm. Pattern information is entirely embedded in types, enabling complete inlining and optimization by the C++ compiler.

\subsection{SIMD Integration Architecture}

SIMD optimization integrates into CTRE's evaluation framework through multiple complementary mechanisms, each targeting distinct pattern classes. The integration preserves CTRE's three-layer evaluation model while introducing vectorized fast paths.

\subsubsection{Dual Evaluation Backend Architecture}

The implementation extends CTRE with two distinct evaluation backends, with automatic backend selection occurring transparently within \texttt{ctre::match}. The selection is based on compile-time pattern type analysis.

\paragraph{Backend Selection in match\_method}

The \texttt{match\_method} structure in \texttt{wrapper.hpp} implements automatic backend dispatch:

\begin{verbatim}
if constexpr (glushkov::is_select<RE>::value) {
    // Alternation pattern → BitNFA
    return bitnfa::match_from_ast<RE>(input);
} else {
    // All other patterns → Base evaluation + SIMD
    return evaluate(...pattern_type_list...);
}
\end{verbatim}

This dispatch is transparent: users invoke \texttt{ctre::match<"pattern">()}, and the system automatically selects the optimal backend based on pattern type extracted at compile time.

\paragraph{Backend 1: Base Evaluation with SIMD}

The primary evaluation path, implemented in \texttt{evaluation.hpp}, interprets pattern types through recursive template instantiation. Each pattern type template (\texttt{repeat}, \texttt{sequence}, \texttt{capture}) has a corresponding \texttt{evaluate()} specialization. SIMD optimizations integrate at the \texttt{repeat<A, B, set<...>>} specialization: compile-time trait extraction determines SIMD applicability, runtime size checks prevent overhead on short inputs, and eligible patterns dispatch to vectorized implementations processing 16-32 characters per iteration. This backend handles repetitions, sequences, literals, captures, and assertions.

\paragraph{Backend 2: BitNFA}

The alternative backend compiles pattern ASTs into explicit NFA representations with enumerated states and transition tables. NFA simulation employs bit-parallel operations: active states are represented as bit vectors, with state transitions applied simultaneously via bitwise operations. This backend is selected for alternation patterns (\texttt{select<Opt1, Opt2, ...>}) where bit-parallel state tracking provides advantages over sequential alternation testing. BitNFA delegates repetition subpatterns back to base CTRE evaluation to exploit SIMD acceleration, avoiding redundant repetition handling implementation.

\subsubsection{SIMD Dispatch Hierarchy}

Within the repetition evaluation specialization, SIMD dispatch follows a waterfall pattern based on pattern characteristics extracted at compile time:

\begin{enumerate}
    \item \textbf{Compile-time eligibility}: Template metaprogramming extracts pattern traits (\texttt{simd\_pattern\_trait<ContentType>}): character range bounds, negation semantics, character class density, multi-range structure. Patterns lacking these traits bypass SIMD entirely through SFINAE.

    \item \textbf{Runtime size threshold}: Input length compared against pattern-dependent threshold (16 bytes for simple patterns, 28 bytes for complex patterns with negation or sparse sets). Short inputs skip SIMD to avoid overhead amortization failure.

    \item \textbf{SIMD technique selection}: Eligible patterns dispatch to specialized implementations:
    \begin{itemize}
        \item \textbf{Multi-range} (\texttt{[a-zA-Z]}, \texttt{[0-9a-fA-F]}): Uses range-based comparison (2 comparisons + AND per character) when pattern contains 2+ non-adjacent ranges
        \item \textbf{Shufti} (\texttt{[aeiou]}): Employs \texttt{pshufb}-based lookup table for sparse character sets ($\leq$16 characters)
        \item \textbf{Direct comparison} (\texttt{[a-z]}, \texttt{[0-9]}): Simple range bounds checking for single dense ranges
        \item \textbf{Single character} (\texttt{a+}, \texttt{9*}): Optimized \texttt{pcmpeqb} + \texttt{pmovmskb} for single-character repetitions
    \end{itemize}

    \item \textbf{Scalar fallback}: If SIMD implementations decline (pattern characteristics unsuitable) or return no match, evaluation continues via standard Glushkov NFA character iteration.
\end{enumerate}

\subsubsection{Greedy Quantifier Optimization}

Standard greedy quantifiers (\texttt{*}, \texttt{+}, \texttt{\{m,n\}}) potentially require backtracking. SIMD optimization applies when compile-time first-set analysis determines backtracking is unnecessary: if the first character sets of repetition content and subsequent pattern are disjoint (\texttt{!collides(first(Content), first(Tail))}), the greedy quantifier is transformed to possessive form at evaluation time, enabling SIMD application. Patterns requiring actual backtracking (e.g., \texttt{a+a}) fall back to recursive scalar evaluation.

\subsubsection{Zero-Overhead Preservation}

The integration architecture maintains zero-overhead abstraction through compile-time code path elimination. Pattern types incompatible with SIMD (assertions, backreferences, atomic groups) never instantiate SIMD-related template specializations due to SFINAE and \texttt{requires} clauses. The compiler's dead code elimination removes all SIMD dispatch logic from binaries handling only SIMD-incompatible patterns.

Captures (\texttt{capture<N, ...>}) are orthogonal to SIMD optimization: they mark iterator positions before and after inner pattern evaluation but do not affect the evaluation strategy for inner content. A captured repetition \texttt{([a-z]+)} applies SIMD to the inner \texttt{repeat} while recording capture boundaries.
